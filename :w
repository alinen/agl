// Copyright, 2020, Savvy Sine, Aline Normoyle
#ifndef AGL_TRIANGLE_MESH_H_
#define AGL_TRIANGLE_MESH_H_

#include <vector>
#include "agl/agl.h"

namespace agl {

/**
 * @brief Base class for indexed triangle meshes
 * 
 * Override this class to create your own meshes.
 * @verbinclude undulate.cpp
 */
class TriangleMesh {
 public:
  virtual ~TriangleMesh();

  /**
   * @brief Draw this mesh
   *
   * Typically, users do not need to call this function. It is called from 
   * Renderer.
   * @see Renderer::mesh(const TriangleMesh&)
   */ 
  virtual void render() const;

  /**
   * @brief Return the vertex array object corresponding to this mesh
   */ 
  GLuint vao() const { return _vao; }

  /**
   * @brief Return whether this mesh has UV coordinates defined.
   */ 
  bool hasUV() const { return _hasUV; }

  /**
   * @brief Query whether or not this is a dynamic mesh
   * 
   * Dynamic meshes can change vertex quantities (e.g. position, normal, etc.)
   * at runtime. Dynamic meshes require more memory and are generally slower.
   * Meshes are static (e.g. assumed not to change) by default.
   *
   * To create a dynamic mesh, subclass this class and set _isDynamic to true
   * in the constructor.
   * 
   * @verbinclude undulate.cpp
   * @see setIsDynamic(bool)
   */
  bool isDynamic() const { return _isDynamic; }

 protected:
  GLuint _nVerts = 0;    // Number of vertices
  GLuint _vao = 0;       // The Vertex Array Object
  bool _hasUV = false;
  bool _isDynamic = false;
  bool _initialized = false;
  std::vector<GLuint> _buffers;  // vertex buffers
  enum VertexData {
    POSITION,
    NORMAL,
    UV,
    TANGENT
  };

  /**
   * @brief Get the number of vertices
   */
  int numVertices() const { return _nVerts; }

  /**
   * @brief Set vertex properties
   * 
   * @verbinclude undulate.cpp
   * @see isDynamic()
   */
  void setVertexData(VertexData type, int vertexId, const vec4& data);

  vec4 vertexData(VertexData type, int vertexId, const vec4& data);

  /**
   * @brief Set whether or not this is a dynamic mesh
   * 
   * Dynamic meshes can change vertex quantities (e.g. position, normal, etc.)
   * at runtime. Dynamic meshes require more memory and are generally slower.
   * Meshes are static (e.g. assumed not to change) by default.
   *
   * To create a dynamic mesh, subclass this class and call setIsDynamic(true)
   * in the constructor. setIsDynamic must be called before the mesh is 
   * initialized and cannot be changed afterwards.
   * 
   * @verbinclude undulate.cpp
   * @see isDynamic()
   */
  virtual void setIsDynamic(bool on);

  /**
   * @brief Override init to specifiy vertex data for the mesh
   *
   * init() will be called automatically the first time render() is called.
   * Overridden implementations of init() should call initBuffers.
   * @see initBuffers(std::vector<GLuint>*,
   *     std::vector<GLfloat>*, std::vector<GLfloat>*, 
   *     std::vector<GLfloat>*, std::vector<GLfloat>*) 
   */
  virtual void init() = 0;

  /**
   * @brief Call initBuffers from init() to set the data for this mesh
   *
   * @see init()
   * @see setIsDynamic(bool)
   */
  virtual void initBuffers(
    std::vector<GLuint>* indices,
    std::vector<GLfloat>* points,
    std::vector<GLfloat>* normals,
    std::vector<GLfloat>* texCoords = nullptr,
    std::vector<GLfloat>* tangents = nullptr);

  virtual void deleteBuffers();

 private:
  // The following members are only non-empty for dynamic meshes
  std::vector<GLfloat> _positions;
  std::vector<GLfloat> _normals;
  std::vector<GLfloat> _uvs;
  std::vector<GLfloat> _tangents;
};

}  // namespace agl
#endif  // AGL_TRIANGLE_MESH_H_
